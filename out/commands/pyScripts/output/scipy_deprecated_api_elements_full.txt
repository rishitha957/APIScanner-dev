scipy.interpolate.splprep(): ~ub, ue : int, optional the end-points of the parameters interval. defaults to u[0] and u[-1]. k : int, optional degree of the spline. cubic splines are recommended. even values of `k` should be avoided especially with a small s-value. ``1 <= k <= 5``, default is 3. task : int, optional if task==0 (default), find t and c for a given smoothing factor, s. if task==1, find t and c for another value of the smoothing factor, s. there must have been a previous call with task=0 or task=1 for the same set of data. if task=-1 find the weighted least square spline for a given set of knots, t. s : float, optional a smoothing condition. the amount of smoothness is determined by satisfying the conditions: ``sum((w * (y - g))**2,axis=0) <= s``, where g(x) is the smoothed interpolation of (x,y). the user can use `s` to control the trade-off between closeness and smoothness of fit. larger `s` means more smoothing while smaller values of `s` indicate less smoothing. recommended values of `s` depend on the weights, w. if the weights represent the inverse of the standard-deviation of y, then a good `s` value should be found in the range ``(m-sqrt(2*m),m+sqrt(2*m))``, where m is the number of data points in x, y, and w. t : int, optional the knots needed for task=-1. full_output : int, optional if non-zero, then return optional outputs. nest : int, optional an over-estimate of the total number of knots of the spline to help in determining the storage space. by default nest=m/2. always large enough is nest=m+k+1. per : int, optional if non-zero, data points are considered periodic with period ``x[m-1] - x[0]`` and a smooth periodic spline approximation is returned. values of ``y[m-1]`` and ``w[m-1]`` are not used. quiet : int, optional non-zero to suppress messages. this parameter is deprecated; use standard python warning filters instead., ./scipy/scipy/interpolate/fitpack.py
scipy.interpolate.splrep(): ~ if task=-1 find the weighted least square spline for a given set of knots, t. these should be interior knots as knots on the ends will be added automatically. s : float, optional a smoothing condition. the amount of smoothness is determined by satisfying the conditions: sum((w * (y - g))**2,axis=0) <= s where g(x) is the smoothed interpolation of (x,y). the user can use s to control the tradeoff between closeness and smoothness of fit. larger s means more smoothing while smaller values of s indicate less smoothing. recommended values of s depend on the weights, w. if the weights represent the inverse of the standard-deviation of y, then a good s value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if weights are supplied. s = 0.0 (interpolating) if no weights are supplied. t : array_like, optional the knots needed for task=-1. if given then task is automatically set to -1. full_output : bool, optional if non-zero, then return optional outputs. per : bool, optional if non-zero, data points are considered periodic with period x[m-1] - x[0] and a smooth periodic spline approximation is returned. values of y[m-1] and w[m-1] are not used. quiet : bool, optional non-zero to suppress messages. this parameter is deprecated; use standard python warning filters instead., ./scipy/scipy/interpolate/fitpack.py
scipy.interpolate._ppform: ~deprecated piecewise polynomial class. warn - _ppform is deprecated -- use PPoly insteadDeprecationWarning, ./scipy/scipy/interpolate/interpolate.py
scipy.interpolate:  warn - _ppform is deprecated -- use PPoly insteadDeprecationWarning, ./scipy/scipy/interpolate/interpolate.py
scipy.interpolate._PPolyBase.extend(): ~parameters ---------- c : ndarray, size (k, m, ...) additional coefficients for polynomials in intervals. note that the first additional interval will be formed using one of the ``self.x`` end points. x : ndarray, size (m,) additional breakpoints. must be sorted in the same order as ``self.x`` and either to the right or to the left of the current breakpoints. right deprecated argument. has no effect. .. deprecated:: 0.19, ./scipy/scipy/interpolate/interpolate.py
scipy.interpolate.splprep(): ~ub, ue : int, optional the end-points of the parameters interval. defaults to u[0] and u[-1]. k : int, optional degree of the spline. cubic splines are recommended. even values of `k` should be avoided especially with a small s-value. ``1 <= k <= 5``, default is 3. task : int, optional if task==0 (default), find t and c for a given smoothing factor, s. if task==1, find t and c for another value of the smoothing factor, s. there must have been a previous call with task=0 or task=1 for the same set of data. if task=-1 find the weighted least square spline for a given set of knots, t. s : float, optional a smoothing condition. the amount of smoothness is determined by satisfying the conditions: ``sum((w * (y - g))**2,axis=0) <= s``, where g(x) is the smoothed interpolation of (x,y). the user can use `s` to control the trade-off between closeness and smoothness of fit. larger `s` means more smoothing while smaller values of `s` indicate less smoothing. recommended values of `s` depend on the weights, w. if the weights represent the inverse of the standard-deviation of y, then a good `s` value should be found in the range ``(m-sqrt(2*m),m+sqrt(2*m))``, where m is the number of data points in x, y, and w. t : int, optional the knots needed for task=-1. full_output : int, optional if non-zero, then return optional outputs. nest : int, optional an over-estimate of the total number of knots of the spline to help in determining the storage space. by default nest=m/2. always large enough is nest=m+k+1. per : int, optional if non-zero, data points are considered periodic with period ``x[m-1] - x[0]`` and a smooth periodic spline approximation is returned. values of ``y[m-1]`` and ``w[m-1]`` are not used. quiet : int, optional non-zero to suppress messages. this parameter is deprecated; use standard python warning filters instead., ./scipy/scipy/interpolate/_fitpack_impl.py
scipy.interpolate.splrep(): ~ if task=-1 find the weighted least square spline for a given set of knots, t. these should be interior knots as knots on the ends will be added automatically. s : float, optional a smoothing condition. the amount of smoothness is determined by satisfying the conditions: sum((w * (y - g))**2,axis=0) <= s, where g(x) is the smoothed interpolation of (x,y). the user can use s to control the tradeoff between closeness and smoothness of fit. larger s means more smoothing while smaller values of s indicate less smoothing. recommended values of s depend on the weights, w. if the weights represent the inverse of the standard-deviation of y, then a good s value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if weights are supplied. s = 0.0 (interpolating) if no weights are supplied. t : array_like, optional the knots needed for task=-1. if given then task is automatically set to -1. full_output : bool, optional if non-zero, then return optional outputs. per : bool, optional if non-zero, data points are considered periodic with period x[m-1] - x[0] and a smooth periodic spline approximation is returned. values of y[m-1] and w[m-1] are not used. quiet : bool, optional non-zero to suppress messages. this parameter is deprecated; use standard python warning filters instead., ./scipy/scipy/interpolate/_fitpack_impl.py
scipy.interpolate.bisplrep(): ~parameters ---------- x, y, z : ndarray rank-1 arrays of data points. w : ndarray, optional rank-1 array of weights. by default ``w=np.ones(len(x))``. xb, xe : float, optional end points of approximation interval in `x`. by default ``xb = x.min(), xe=x.max()``. yb, ye : float, optional end points of approximation interval in `y`. by default ``yb=y.min(), ye = y.max()``. kx, ky : int, optional the degrees of the spline (1 <= kx, ky <= 5). third order (kx=ky=3) is recommended. task : int, optional if task=0, find knots in x and y and coefficients for a given smoothing factor, s. if task=1, find knots and coefficients for another value of the smoothing factor, s. bisplrep must have been previously called with task=0 or task=1. if task=-1, find coefficients for a given set of knots tx, ty. s : float, optional a non-negative smoothing factor. if weights correspond to the inverse of the standard-deviation of the errors in z, then a good s-value should be found in the range ``(m-sqrt(2*m),m+sqrt(2*m))`` where m=len(x). eps : float, optional a threshold for determining the effective rank of an over-determined linear system of equations (0 < eps < 1). `eps` is not likely to need changing. tx, ty : ndarray, optional rank-1 arrays of the knots of the spline for task=-1 full_output : int, optional non-zero to return optional outputs. nxest, nyest : int, optional over-estimates of the total number of knots. if none then ``nxest = max(kx+sqrt(m/2),2*kx+3)``, ``nyest = max(ky+sqrt(m/2),2*ky+3)``. quiet : int, optional non-zero to suppress printing of messages. this parameter is deprecated; use standard python warning filters instead., ./scipy/scipy/interpolate/_fitpack_impl.py
scipy.linalg.solve(): ~parameters ---------- a : (n, n) array_like square input data b : (n, nrhs) array_like input data for the right hand side. sym_pos : bool, optional assume `a` is symmetric and positive definite. this key is deprecated and assume_a = 'pos' keyword is recommended instead. the functionality is the same. it will be removed in the future. lower : bool, optional if true, only the data contained in the lower triangle of `a`. default is to use upper triangle. (ignored for ``'gen'``) overwrite_a : bool, optional allow overwriting data in `a` (may enhance performance). default is false. overwrite_b : bool, optional allow overwriting data in `b` (may enhance performance). default is false. check_finite : bool, optional whether to check that the input matrices contain only finite numbers. disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or nans. assume_a : str, optional valid entries are explained above. transposed: bool, optional if true, ``a^t x = b`` for real matrices, raises `notimplementederror` for complex matrices (only for true). warn - Use of the "debug" keyword is deprecated and this keyword will be removed in future versions of SciPy.DeprecationWarning, ./scipy/scipy/linalg/basic.py
scipy.linalg.solve_triangular():  warn - Use of the "debug" keyword is deprecated and this keyword will be removed in the future versions of SciPy.DeprecationWarning, ./scipy/scipy/linalg/basic.py
scipy.linalg.solve_banded():  warn - Use of the "debug" keyword is deprecated and this keyword will be removed in the future versions of SciPy.DeprecationWarning, ./scipy/scipy/linalg/basic.py
scipy.linalg.eigh(): ~ this keyword is ignored for standard problems. overwrite_a : bool, optional whether to overwrite data in ``a`` (may improve performance). default is false. overwrite_b : bool, optional whether to overwrite data in ``b`` (may improve performance). default is false. check_finite : bool, optional whether to check that the input matrices contain only finite numbers. disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or nans. turbo : bool, optional *deprecated since v1.5.0, use ``driver=gvd`` keyword instead*. use divide and conquer algorithm (faster but expensive in memory, only for generalized eigenvalue problem and if full set of eigenvalues are requested.). has no significant effect if eigenvectors are not requested. eigvals : tuple (lo, hi), optional *deprecated since v1.5.0, use ``subset_by_index`` keyword instead*. indexes of the smallest and largest (in ascending order) eigenvalues and corresponding eigenvectors to be returned: 0 <= lo <= hi <= m-1. if omitted, all eigenvalues and eigenvectors are returned., ./scipy/scipy/linalg/decomp.py
scipy.linalg.eigvalsh(): ~ this keyword is ignored for standard problems. overwrite_a : bool, optional whether to overwrite data in ``a`` (may improve performance). default is false. overwrite_b : bool, optional whether to overwrite data in ``b`` (may improve performance). default is false. check_finite : bool, optional whether to check that the input matrices contain only finite numbers. disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or nans. turbo : bool, optional *deprecated by ``driver=gvd`` option*. has no significant effect for eigenvalue computations since no eigenvectors are requested. ..deprecated in v1.5.0 eigvals : tuple (lo, hi), optional *deprecated by ``subset_by_index`` keyword*. indexes of the smallest and largest (in ascending order) eigenvalues and corresponding eigenvectors to be returned: 0 <= lo <= hi <= m-1. if omitted, all eigenvalues and eigenvectors are returned. .. deprecated in v1.5.0, ./scipy/scipy/linalg/decomp.py
scipy.misc.docformat(): @np.deprecate # scipy.misc.docformat is deprecated in Scipy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.inherit_docstring_from(): @np.deprecate # scipy.misc.inherit_docstring_from is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.extend_notes_in_docstring(): @np.deprecate # scipy.misc.extend_notes_in_docstring is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.replace_notes_in_docstring(): @np.deprecate # scipy.misc.replace_notes_in_docstring is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.indentcount_lines(): @np.deprecate # scipy.misc.indentcount_lines is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.filldoc(): @np.deprecate # scipy.misc.filldoc is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.unindent_dict(): @np.deprecate # scipy.misc.unindent_dict is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.misc.unindent_string(): @np.deprecate # scipy.misc.unindent_string is deprecated in SciPy 1.3.0, ./scipy/scipy/misc/doccer.py
scipy.optimize._minimize_tnc(): ~options ------- eps : float or ndarray if `jac is none` the absolute step size used for numerical approximation of the jacobian via forward differences. scale : list of floats scaling factors to apply to each variable. if none, the factors are up-low for interval bounded variables and 1+|x] fo the others. defaults to none. offset : float value to subtract from each variable. if none, the offsets are (up+low)/2 for interval bounded variables and x for the others. disp : bool set to true to print convergence messages. maxcgit : int maximum number of hessian*vector evaluations per main iteration. if maxcgit == 0, the direction chosen is -gradient if maxcgit < 0, maxcgit is set to max(1,min(50,n/2)). defaults to -1. maxiter : int, optional maximum number of function evaluations. this keyword is deprecated in favor of `maxfun`. only if `maxfun` is none is this keyword used. eta : float severity of the line search. if < 0 or > 1, set to 0.25. defaults to -1. stepmx : float maximum step for the line search. may be increased during call. if too small, it will be set to 10.0. defaults to 0. accuracy : float relative precision for finite difference calculations. if <= machine_precision, set to sqrt(machine_precision). defaults to 0. minfev : float minimum function value estimate. defaults to 0. ftol : float precision goal for the value of f in the stopping criterion. if ftol < 0.0, ftol is set to 0.0 defaults to -1. xtol : float precision goal for the value of x in the stopping criterion (after applying x scaling factors). if xtol < 0.0, xtol is set to sqrt(machine_precision). defaults to -1. gtol : float precision goal for the value of the projected gradient in the stopping criterion (after applying x scaling factors). if gtol < 0.0, gtol is set to 1e-2 * sqrt(accuracy). setting it to 0.0 is not recommended. defaults to -1. rescale : float scaling factor (in log10) used to trigger f value rescaling. if 0, rescale at each iteration. if a large value, never rescale. if < 0, rescale is set to 1.3. finite_diff_rel_step : none or array_like, optional if `jac in ['2-point', '3-point', 'cs']` the relative step size to use for numerical approximation of the jacobian. the absolute step size is computed as ``h = rel_step * sign(x0) * max(1, abs(x0))``, possibly adjusted to fit into the bounds. for ``method='3-point'`` the sign of `h` is ignored. if none (default) then step is selected automatically. maxfun : int maximum number of function evaluations. if none, `maxfun` is set to max(100, 10*len(x0)). defaults to none., ./scipy/scipy/optimize/tnc.py
scipy.signal.firwin(): ~nyq : float, optional *deprecated. use `fs` instead.* this is the nyquist frequency. each frequency in `cutoff` must be between 0 and `nyq`. default is 1. fs : float, optional the sampling frequency of the signal. each frequency in `cutoff` must be between 0 and ``fs/2``. default is 2., ./scipy/scipy/signal/fir_filter_design.py
scipy.signal.firwin2(): ~parameters ---------- numtaps : int the number of taps in the fir filter. `numtaps` must be less than `nfreqs`. freq : array_like, 1-d the frequency sampling points. typically 0.0 to 1.0 with 1.0 being nyquist. the nyquist frequency is half `fs`. the values in `freq` must be nondecreasing. a value can be repeated once to implement a discontinuity. the first value in `freq` must be 0, and the last value must be ``fs/2``. values 0 and ``fs/2`` must not be repeated. gain : array_like the filter gains at the frequency sampling points. certain constraints to gain values, depending on the filter type, are applied, see notes for details. nfreqs : int, optional the size of the interpolation mesh used to construct the filter. for most efficient behavior, this should be a power of 2 plus 1 (e.g, 129, 257, etc). the default is one more than the smallest power of 2 that is not less than `numtaps`. `nfreqs` must be greater than `numtaps`. window : string or (string, float) or float, or none, optional window function to use. default is "hamming". see `scipy.signal.get_window` for the complete list of possible values. if none, no window function is applied. nyq : float, optional *deprecated. use `fs` instead.* this is the nyquist frequency. each frequency in `freq` must be between 0 and `nyq`. default is 1. antisymmetric : bool, optional whether resulting impulse response is symmetric/antisymmetric. see notes for more details. fs : float, optional the sampling frequency of the signal. each frequency in `cutoff` must be between 0 and ``fs/2``. default is 2., ./scipy/scipy/signal/fir_filter_design.py
scipy.signal.remez(): ~parameters ---------- numtaps : int the desired number of taps in the filter. the number of taps is the number of terms in the filter, or the filter order plus one. bands : array_like a monotonic sequence containing the band edges. all elements must be non-negative and less than half the sampling frequency as given by `fs`. desired : array_like a sequence half the size of bands containing the desired gain in each of the specified bands. weight : array_like, optional a relative weighting to give to each band region. the length of `weight` has to be half the length of `bands`. hz : scalar, optional *deprecated. use `fs` instead.* the sampling frequency in hz. default is 1. type : {'bandpass', 'differentiator', 'hilbert'}, optional the type of filter:, ./scipy/scipy/signal/fir_filter_design.py
scipy.signal.firls(): ~parameters ---------- numtaps : int the number of taps in the fir filter. `numtaps` must be odd. bands : array_like a monotonic nondecreasing sequence containing the band edges in hz. all elements must be non-negative and less than or equal to the nyquist frequency given by `nyq`. desired : array_like a sequence the same size as `bands` containing the desired gain at the start and end point of each band. weight : array_like, optional a relative weighting to give to each band region when solving the least squares problem. `weight` has to be half the size of `bands`. nyq : float, optional *deprecated. use `fs` instead.* nyquist frequency. each frequency in `bands` must be between 0 and `nyq` (inclusive). default is 1. fs : float, optional the sampling frequency of the signal. each frequency in `bands` must be between 0 and ``fs/2`` (inclusive). default is 2., ./scipy/scipy/signal/fir_filter_design.py
scipy.signal.windows.hanning(): @np.deprecate # scipy.signal.windows.hann, ./scipy/scipy/signal/windows/windows.py
scipy.sparse.bsr_matrix.matvec(): @np.deprecate # BSR matvec is deprecated in SciPy 0.19.0. Use * operator instead., ./scipy/scipy/sparse/bsr.py
scipy.sparse.bsr_matrix.matmat(): @np.deprecate # BSR matmat is deprecated in SciPy 0.19.0. Use * operator instead., ./scipy/scipy/sparse/bsr.py
scipy.sparse.linalg.isolve.gmres(): ~ the default value for `atol` will be changed in a future release. for future compatibility, specify `atol` explicitly. restart : int, optional number of iterations between restarts. larger values increase iteration cost, but may be necessary for convergence. default is 20. maxiter : int, optional maximum number of iterations (restart cycles). iteration will stop after maxiter steps even if the specified tolerance has not been achieved. m : {sparse matrix, dense matrix, linearoperator} inverse of the preconditioner of a. m should approximate the inverse of a and be easy to solve for (see notes). effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance. by default, no preconditioner is used. callback : function user-supplied function to call after each iteration. it is called as `callback(args)`, where `args` are selected by `callback_type`. callback_type : {'x', 'pr_norm', 'legacy'}, optional callback function argument requested: - ``x``: current iterate (ndarray), called on every restart - ``pr_norm``: relative (preconditioned) residual norm (float), called on every inner iteration - ``legacy`` (default): same as ``pr_norm``, but also changes the meaning of 'maxiter' to count inner iterations instead of restart cycles. restrt : int, optional deprecated - use `restart` instead. warn - scipy.sparse.linalg.gmres called without specifying `callback_type`. The default value will be changed in a future release. For compatibility, specify a value for `callback_type` explicitly, e.g., ``{name}(..., callback_type='pr_norm')``, or to retain the old behavior ``{name}(..., callback_type='legacy')``DeprecationWarning, ./scipy/scipy/sparse/linalg/isolve/iterative.py
scipy.sparse.linalg.isolve.lgmres():  warn - scipy.sparse.linalg.lgmres called without specifying `atol`. The default value will change in the future. To preserve current behavior, set ``atol=tol``.DeprecationWarning, ./scipy/scipy/sparse/linalg/isolve/lgmres.py
scipy.sparse.linalg.isolve.gcrotmk():  warn - scipy.sparse.linalg.gcrotmk called without specifying `atol`. The default value will change in the future. To preserve current behavior, set ``atol=tol``.DeprecationWarning, ./scipy/scipy/sparse/linalg/isolve/_gcrotmk.py
scipy.sparse._deprecated(): @deprecate. # scipy.sparse.sparsetools is a private module for scipy.sparse, and should not be used., ./scipy/scipy/sparse/sparsetools.py
scipy.spatial._validate_wminkowski_kwargs(): @_deprecated. # 'wminkowski' metric is deprecated and will be removed in SciPy 1.8.0, use 'minkowski' instead., ./scipy/scipy/spatial/distance.py
scipy.spatial.wminkowski(): ~notes ----- `wminkowski` is deprecated and will be removed in scipy 1.8.0. use `minkowski` with the ``w`` argument instead. warn - scipy.distance.wminkowski is deprecated and will be removed in SciPy 1.8.0, use scipy.distance.minkowski instead.DeprecationWarning, ./scipy/scipy/spatial/distance.py
scipy.spatial.matching(): ~this is a deprecated synonym for :func:`hamming`., @np.deprecate # spatial.distance.matching is deprecated in scipy 1.0.0; use spatial.distance.hamming instead., ./scipy/scipy/spatial/distance.py
scipy.spatial.pdist(): ~parameters ---------- x : ndarray an m by n array of m original observations in an n-dimensional space. metric : str or function, optional the distance metric to use. the distance function can be 'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation', 'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'. *args : tuple. deprecated. additional arguments should be passed as keyword arguments **kwargs : dict, optional extra arguments to `metric`: refer to each metric documentation for a list of all possible arguments. 'wminkowski' is deprecated and will be removed in scipy 1.8.0. use 'minkowski' instead., ./scipy/scipy/spatial/distance.py
scipy.spatial.cdist(): ~parameters ---------- xa : ndarray an :math:`m_a` by :math:`n` array of :math:`m_a` original observations in an :math:`n`-dimensional space. inputs are converted to float type. xb : ndarray an :math:`m_b` by :math:`n` array of :math:`m_b` original observations in an :math:`n`-dimensional space. inputs are converted to float type. metric : str or callable, optional the distance metric to use. if a string, the distance function can be 'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation', 'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'wminkowski', 'yule'. *args : tuple. deprecated. additional arguments should be passed as keyword arguments **kwargs : dict, optional extra arguments to `metric`: refer to each metric documentation for a list of all possible arguments. 'wminkowski' is deprecated and will be removed in scipy 1.8.0. use 'minkowski' instead., ./scipy/scipy/spatial/distance.py
scipy.stats.itemfreq(): @np.deprecate # `itemfreq` is deprecated and will be removed in a future version. Use instead `np.unique(..., return_counts=True)`, ./scipy/scipy/stats/stats.py
scipy.stats.iqr(): ~ * 'raw' : no scaling, just return the raw iqr. **deprecated!** use `scale=1` instead. * 'normal' : scale by :math:`2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349`. the default is 1.0. the use of scale='raw' is deprecated. array-like scale is also allowed, as long as it broadcasts correctly to the output such that ``out / scale`` is a valid operation. the output dimensions depend on the input array, `x`, the `axis` argument, and the `keepdims` flag. nan_policy : {'propagate', 'raise', 'omit'}, optional defines how to handle when input contains nan. the following options are available (default is 'propagate'):, ./scipy/scipy/stats/stats.py
scipy.stats.median_absolute_deviation(): @_median_absolute_deviation_deprec_msg.deprecate # median_abs_deviation, ./scipy/scipy/stats/stats.py
scipy.stats.kendalltau(): ~parameters ---------- x, y : array_like arrays of rankings, of the same shape. if arrays are not 1-d, they will be flattened to 1-d. initial_lexsort : bool, optional unused (deprecated). nan_policy : {'propagate', 'raise', 'omit'}, optional defines how to handle when input contains nan. the following options are available (default is 'propagate'):, ./scipy/scipy/stats/stats.py
scipy.stats.mannwhitneyu(): ~ * none: computes p-value half the size of the 'two-sided' p-value and a different u statistic. the default behavior is not the same as using 'less' or 'greater'; it only exists for backward compatibility and is deprecated. * 'two-sided' * 'less': one-sided * 'greater': one-sided use of the none option is deprecated. returns ------- statistic : float the mann-whitney u statistic, equal to min(u for x, u for y) if `alternative` is equal to none (deprecated; exists for backward compatibility), and u for y otherwise. pvalue : float p-value assuming an asymptotic normal distribution. one-sided or two-sided, depending on the choice of `alternative`., ./scipy/scipy/stats/stats.py
scipy.stats.rv_continuous: ~parameters ---------- momtype : int, optional the type of generic moment calculation to use: 0 for pdf, 1 (default) for ppf. a : float, optional lower bound of the support of the distribution, default is minus infinity. b : float, optional upper bound of the support of the distribution, default is plus infinity. xtol : float, optional the tolerance for fixed point calculation for generic ppf. badvalue : float, optional the value in a result arrays that indicates a value that for which some argument restriction is violated, default is np.nan. name : str, optional the name of the instance. this string is used to construct the default example for distributions. longname : str, optional this string is used as part of the first line of the docstring returned when a subclass has no docstring of its own. note: `longname` exists for backwards compatibility, do not use for new subclasses. shapes : str, optional the shape of the distribution. for example ``"m, n"`` for a distribution that takes two integers as the two shape arguments for all its methods. if not provided, shape parameters will be inferred from the signature of the private methods, ``_pdf`` and ``_cdf`` of the instance. extradoc : str, optional, deprecated this string is used as the last part of the docstring returned when a subclass has no docstring of its own. note: `extradoc` exists for backwards compatibility, do not use for new subclasses. seed : {none, int, `~np.random.randomstate`, `~np.random.generator`}, optional this parameter defines the object to use for drawing random variates. if `seed` is `none` the `~np.random.randomstate` singleton is used. if `seed` is an int, a new ``randomstate`` instance is used, seeded with seed. if `seed` is already a ``randomstate`` or ``generator`` instance, then that object is used. default is none., ./scipy/scipy/stats/_distn_infrastructure.py
scipy._lib._DeprecationHelperStr: ~helper class used by deprecate_cython_api, ./scipy/scipy/_lib/deprecation.py
scipy._lib._deprecated(): ~deprecate a function by emitting a warning on use., ./scipy/scipy/_lib/deprecation.py
scipy._lib.deprecate_cython_api(): ~deprecate an exported cdef function in a public cython api module. only functions can be deprecated; typedefs etc. cannot. parameters ---------- module : module public cython api module (e.g. scipy.linalg.cython_blas). routine_name : str name of the routine to deprecate. may also be a fused-type routine (in which case its all specializations are deprecated). new_name : str new name to include in the deprecation warning message message : str additional text in the deprecation warning message >>> from scipy._lib.deprecation import deprecate_cython_api >>> import scipy.linalg.cython_blas as mod >>> deprecate_cython_api(mod, "dgemm", "dgemm_new", ... message="deprecated in scipy 1.5.0") >>> del deprecate_cython_api, mod after this, cython modules that use the deprecated function emit a deprecation warning when they are imported., ./scipy/scipy/_lib/deprecation.py
scipy._lib._DeprecationHelperStr.__eq__():  warn - DeprecationWarning, ./scipy/scipy/_lib/deprecation.py
scipy._lib.DeprecatedImport: ~deprecated import with redirection and warning. if this has to be deprecated, do:: spam = deprecatedimport("foo.spam", "baz"), ./scipy/scipy/_lib/_util.py
